from typing import Any, Optional, Tuple, Union
import numpy as np

class Array:
  dtype: np.dtype
  ndim: int
  shape: Tuple[int, ...]
  size: int

  def __getitem__(self, key, indices_are_sorted=False,
                  unique_indices=False) -> Any: ...
  def __setitem__(self, key, value) -> Any: ...
  def __len__(self) -> Any: ...
  def __iter__(self) -> Any: ...
  def __reversed__(self) -> Any: ...

  # Comparisons
  def __lt__(self, other) -> Any: ...
  def __le__(self, other) -> Any: ...
  def __eq__(self, other) -> Any: ...
  def __ne__(self, other) -> Any: ...
  def __gt__(self, other) -> Any: ...
  def __ge__(self, other) -> Any: ...

  # Unary arithmetic

  def __neg__(self) -> Any: ...
  def __pos__(self) -> Any: ...
  def __abs__(self) -> Any: ...
  def __invert__(self) -> Any: ...

  # Binary arithmetic

  def __add__(self, other) -> Any: ...
  def __sub__(self, other) -> Any: ...
  def __mul__(self, other) -> Any: ...
  def __matmul__(self, other) -> Any: ...
  def __truediv__(self, other) -> Any: ...
  def __floordiv__(self, other) -> Any: ...
  def __mod__(self, other) -> Any: ...
  def __divmod__(self, other) -> Any: ...
  def __pow__(self, other) -> Any: ...
  def __lshift__(self, other) -> Any: ...
  def __rshift__(self, other) -> Any: ...
  def __and__(self, other) -> Any: ...
  def __xor__(self, other) -> Any: ...
  def __or__(self, other) -> Any: ...

  def __radd__(self, other) -> Any: ...
  def __rsub__(self, other) -> Any: ...
  def __rmul__(self, other) -> Any: ...
  def __rmatmul__(self, other) -> Any: ...
  def __rtruediv__(self, other) -> Any: ...
  def __rfloordiv__(self, other) -> Any: ...
  def __rmod__(self, other) -> Any: ...
  def __rdivmod__(self, other) -> Any: ...
  def __rpow__(self, other) -> Any: ...
  def __rlshift__(self, other) -> Any: ...
  def __rrshift__(self, other) -> Any: ...
  def __rand__(self, other) -> Any: ...
  def __rxor__(self, other) -> Any: ...
  def __ror__(self, other) -> Any: ...

  def __bool__(self) -> Any: ...
  def __complex__(self) -> Any: ...
  def __int__(self) -> Any: ...
  def __float__(self) -> Any: ...
  def __round__(self, ndigits=None) -> Any: ...

  def __index__(self) -> Any: ...

  # np.ndarray methods:
  def all(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, out=None,
          keepdims=None) -> Any: ...
  def any(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, out=None,
          keepdims=None) -> Any: ...
  def argmax(self, axis: Optional[int] = None, out=None, keepdims=None) -> Any: ...
  def argmin(self, axis: Optional[int] = None, out=None, keepdims=None) -> Any: ...
  def argpartition(self, kth, axis=-1, kind='introselect', order=None) -> Any: ...
  def argsort(self, axis: Optional[int] = -1, kind='quicksort', order=None) -> Any: ...
  def astype(self, dtype) -> Any: ...
  def choose(self, choices, out=None, mode='raise') -> Any: ...
  def clip(self, min=None, max=None, out=None) -> Any: ...
  def compress(self, condition, axis: Optional[int] = None, out=None) -> Any: ...
  def conj(self) -> Any: ...
  def conjugate(self) -> Any: ...
  def copy(self) -> Any: ...
  def cumprod(self, axis: Optional[Union[int, Tuple[int, ...]]] = None,
              dtype=None, out=None) -> Any: ...
  def cumsum(self, axis: Optional[Union[int, Tuple[int, ...]]] = None,
             dtype=None, out=None) -> Any: ...
  def diagonal(self, offset=0, axis1: int = 0, axis2: int = 1) -> Any: ...
  def dot(self, b, *, precision=None) -> Any: ...
  def flatten(self) -> Any: ...
  @property
  def imag(self) -> Any: ...
  def item(self, *args) -> Any: ...
  def max(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, out=None,
          keepdims=None, initial=None, where=None) -> Any: ...
  def mean(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, dtype=None,
           out=None, keepdims=False, *, where=None,) -> Any: ...
  def min(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, out=None,
          keepdims=None, initial=None, where=None) -> Any: ...
  @property
  def nbytes(self) -> Any: ...
  def nonzero(self, *, size=None, fill_value=None) -> Any: ...
  def prod(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, dtype=None,
           out=None, keepdims=None, initial=None, where=None) -> Any: ...
  def ptp(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, out=None,
          keepdims=False,) -> Any: ...
  def ravel(self, order='C') -> Any: ...
  @property
  def real(self) -> Any: ...
  def repeat(self, repeats, axis: Optional[int] = None, *,
             total_repeat_length=None) -> Any: ...
  def reshape(self, *args, order='C') -> Any: ...
  def round(self, decimals=0, out=None) -> Any: ...
  def searchsorted(self, v, side='left', sorter=None) -> Any: ...
  def sort(self, axis: Optional[int] = -1, kind='quicksort', order=None) -> Any: ...
  def squeeze(self, axis: Optional[Union[int, Tuple[int, ...]]] = None) -> Any: ...
  def std(self, axis: Optional[Union[int, Tuple[int, ...]]] = None,
          dtype=None, out=None, ddof=0, keepdims=False, *, where=None) -> Any: ...
  def sum(self, axis: Optional[Union[int, Tuple[int, ...]]] = None, dtype=None,
          out=None, keepdims=None, initial=None, where=None) -> Any: ...
  def swapaxes(self, axis1: int, axis2: int) -> Any: ...
  def take(self, indices, axis: Optional[int] = None, out=None,
           mode=None) -> Any: ...
  def tobytes(self, order='C') -> Any: ...
  def tolist(self) -> Any: ...
  def trace(self, offset=0, axis1: int = 0, axis2: int = 1, dtype=None,
            out=None) -> Any: ...
  def transpose(self, *args) -> Any: ...
  def var(self, axis: Optional[Union[int, Tuple[int, ...]]] = None,
          dtype=None, out=None, ddof=0, keepdims=False, *, where=None) -> Any: ...
  def view(self, dtype=None, type=None) -> Any: ...

  # Even though we don't always support the NumPy array protocol, e.g., for
  # tracer types, for type checking purposes we must declare support so we
  # implement the NumPy ArrayLike protocol.
  def __array__(self) -> Any: ...

  def __dlpack__(self) -> Any: ...

  # JAX extensions
  @property
  def at(self) -> Any: ...
  @property
  def aval(self) -> Any: ...
  @property
  def weak_type(self) -> bool: ...
